const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env.local') });

const { getRecentMessages, sendMessage } = require('./imessage');
const { generateReply } = require('./agent');
const db = require('../shared/db');

const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL_MS || '3000');
const REPLY_DELAY_MIN = parseInt(process.env.REPLY_DELAY_MIN_MS || '2000');
const REPLY_DELAY_MAX = parseInt(process.env.REPLY_DELAY_MAX_MS || '8000');

function getSetting(key) {
  const row = db.prepare('SELECT value FROM settings WHERE key = ?').get(key);
  return row ? row.value : null;
}

function isContactAllowlisted(handle) {
  const contact = db.prepare(
    'SELECT * FROM contacts WHERE phone_or_handle = ? AND auto_reply = 1'
  ).get(handle);
  return !!contact;
}

function markSeen(messageId) {
  db.prepare('INSERT OR IGNORE INTO seen_messages (message_id) VALUES (?)').run(messageId);
}

function isAlreadySeen(messageId) {
  const row = db.prepare('SELECT 1 FROM seen_messages WHERE message_id = ?').get(messageId);
  return !!row;
}

function logMessage(handle, direction, body, autoGenerated = false) {
  db.prepare(`
    INSERT INTO message_log (phone_or_handle, direction, body, auto_generated)
    VALUES (?, ?, ?, ?)
  `).run(handle, direction, body, autoGenerated ? 1 : 0);
}

function randomDelay(min, max) {
  return new Promise(resolve => {
    const delay = Math.floor(Math.random() * (max - min + 1)) + min;
    setTimeout(resolve, delay);
  });
}

// Tapback reactions show up as "Loved ...", "Liked ...", etc. â€” skip them
const TAPBACK_PREFIXES = ['Loved "', 'Liked "', 'Disliked "', 'Laughed at "', 'Emphasized "', 'Questioned "'];

function isTapback(body) {
  return TAPBACK_PREFIXES.some(prefix => body.startsWith(prefix));
}

async function processMessage(message) {
  const { id, body, handle } = message;

  if (isAlreadySeen(id)) return;
  markSeen(id);

  if (isTapback(body)) {
    console.log(`[DAEMON] Skipping tapback from ${handle}: "${body}"`);
    return;
  }

  logMessage(handle, 'inbound', body);

  const agentEnabled = getSetting('agent_enabled') === '1';
  if (!agentEnabled) {
    console.log(`[DAEMON] Agent disabled, skipping message from ${handle}`);
    return;
  }

  if (!isContactAllowlisted(handle)) {
    console.log(`[DAEMON] ${handle} not in allowlist, skipping`);
    return;
  }

  console.log(`[DAEMON] Processing message from ${handle}: "${body}"`);

  const reply = await generateReply(handle, body);
  if (!reply) {
    console.error(`[DAEMON] Failed to generate reply for ${handle}`);
    return;
  }

  await randomDelay(REPLY_DELAY_MIN, REPLY_DELAY_MAX);

  const result = sendMessage(handle, reply);
  if (result === 'sent') {
    logMessage(handle, 'outbound', reply, true);
    console.log(`[DAEMON] Sent reply to ${handle}: "${reply}"`);
  } else {
    console.error(`[DAEMON] Failed to send message to ${handle}`);
  }
}

async function poll() {
  try {
    const messages = getRecentMessages(2);
    for (const msg of messages) {
      await processMessage(msg);
    }
  } catch (err) {
    console.error('[DAEMON] Poll error:', err.message);
  }
}

console.log('[DAEMON] iMessage Agent starting...');
console.log(`[DAEMON] Polling every ${POLL_INTERVAL}ms`);

poll();
setInterval(poll, POLL_INTERVAL);
